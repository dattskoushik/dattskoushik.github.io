<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <title>PostgreSQL Query Planning Deep Dive | Suchindra Koushik</title>
    <meta name="description" content="Understanding how PostgreSQL's query planner works and how to optimize your queries.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Roboto+Mono:wght@400;500&family=Roboto+Slab:wght@400;700&display=swap" rel="stylesheet">

    <!-- Oat UI -->
    <link rel="stylesheet" href="../assets/vendor/oat.min.css">
    <script src="../assets/vendor/oat.min.js" defer></script>

    <script src="../assets/js/theme.js"></script>

    <style>
        :root {
            /* Fonts */
            --font-serif: 'Roboto Slab', serif;
            --font-sans: 'Inter', sans-serif;
            --font-mono: 'Roboto Mono', monospace;

            /* Spacing overrides if needed */
            --space-xl: 4rem;
            --space-lg: 2.5rem;
            --space-md: 1.5rem;
            --space-sm: 1rem;
        }

        /* Dark Theme (Default) */
        [data-theme="dark"] {
            --background: #0a0a0a;
            --foreground: #ededed;
            --card: #111111;
            --card-foreground: #ededed;
            --muted: #1f1f23;
            --muted-foreground: #a1a1aa;
            --border: #27272a;
            --primary: #ffffff;
            --primary-foreground: #000000;
            --secondary: #1f1f23;
            --secondary-foreground: #ededed;
            --accent: #ffffff;
            --accent-foreground: #000000;
            --ring: #27272a;
            --input: #1f1f23;
            /* Custom */
            --header-bg: rgba(10, 10, 10, 0.8);
            --code-bg: #1f1f23;
        }

        /* Light Theme */
        [data-theme="light"] {
            --background: #f4f4f5;
            --foreground: #18181b;
            --card: #ffffff;
            --card-foreground: #18181b;
            --muted: #e4e4e7;
            --muted-foreground: #52525b;
            --border: #e4e4e7;
            --primary: #000000;
            --primary-foreground: #ffffff;
            --secondary: #e4e4e7;
            --secondary-foreground: #18181b;
            --accent: #000000;
            --accent-foreground: #ffffff;
            --ring: #e4e4e7;
            --input: #ffffff;
            /* Custom */
            --header-bg: rgba(244, 244, 245, 0.8);
            --code-bg: #e4e4e7;
        }

        body {
            background-color: var(--background);
            color: var(--foreground);
            font-family: var(--font-sans);
        }

        /* Header Styling */
        header.site-header {
            position: sticky;
            top: 0;
            z-index: 50;
            background-color: var(--header-bg);
            backdrop-filter: blur(8px);
            border-bottom: 1px solid var(--border);
            padding: var(--space-sm) 0;
        }

        header .container {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logo {
            font-weight: 700;
            text-decoration: none;
            color: var(--foreground);
        }

        nav.nav-links {
            display: flex;
            gap: var(--space-md);
            align-items: center;
        }

        nav.nav-links a {
            text-decoration: none;
            color: var(--muted-foreground);
            font-size: 0.9rem;
            font-weight: 500;
            transition: color 0.2s;
        }
        nav.nav-links a:hover, nav.nav-links a.active {
            color: var(--foreground);
        }

        /* Mobile Menu */
        .mobile-menu-btn {
            display: none;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--foreground);
            cursor: pointer;
            padding: 0;
        }

        @media (max-width: 768px) {
            .mobile-menu-btn {
                display: block;
            }
            nav.nav-links {
                display: none;
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                flex-direction: column;
                background: var(--background);
                border-bottom: 1px solid var(--border);
                padding: var(--space-md);
                gap: var(--space-sm);
            }
            nav.nav-links.active {
                display: flex;
            }
        }

        /* Footer */
        .site-footer {
            margin-top: var(--space-xl);
            padding: var(--space-lg) 0;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--muted-foreground);
            font-size: 0.875rem;
        }
        .social-links {
            display: flex;
            gap: var(--space-sm);
        }
        .social-links a {
            color: var(--muted-foreground);
            text-decoration: none;
        }
        .social-links a:hover {
            color: var(--foreground);
        }

        /* Theme Toggle */
        #theme-toggle {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0;
            margin-left: var(--space-sm);
            color: var(--foreground);
        }

        /* Typography overrides */
        h1, h2, h3, h4, h5, h6 {
            font-family: var(--font-serif);
            color: var(--foreground);
        }

        nav.nav-links a, .button, button {
            font-family: var(--font-mono);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        body {
            line-height: 1.7;
        }

        code, pre {
            font-family: var(--font-mono);
        }

        /* Grid Utility */
        .grid-2-col {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--space-md);
        }
        @media (min-width: 768px) {
            .grid-2-col {
                grid-template-columns: 1fr 1fr;
            }
        }

        /* Utility overrides */
        .text-muted {
            color: var(--muted-foreground);
        }
    </style>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">

</head>
<body data-theme="dark">

    <header class="site-header">
        <div class="container">
            <a href="../index.html" class="logo">Suchindra Koushik</a>
            <button class="mobile-menu-btn" aria-label="Toggle menu" aria-expanded="false">â˜°</button>
            <nav class="nav-links">
                <a href="../index.html" class="">Home</a>
                <a href="../blog/index.html" class="active">Writing</a>
                <a href="../projects.html" class="">Projects</a>
                <a href="../about.html" class="">About</a>
                <a href="../resume.html" class="">Resume</a>
                <button id="theme-toggle" aria-label="Toggle theme">ðŸŒ™</button>
            </nav>
        </div>
    </header>

    <main class="container" >

    <article style="max-width: 800px; margin: 0 auto; padding: var(--space-xl) 0;">
        <header style="margin-bottom: var(--space-lg);">
            <a href="index.html" class="text-muted" style="text-decoration: none; display: inline-block; margin-bottom: var(--space-sm);">&larr; Back to Writing</a>
            <div class="text-muted" style="margin-bottom: var(--space-sm); font-size: 0.875rem;">
                Databases â€¢ 2024-02-10 â€¢ 12 min
            </div>
            <h1 style="margin-bottom: var(--space-md); font-size: 2.5rem; line-height: 1.2;">PostgreSQL Query Planning Deep Dive</h1>
        </header>

        <div class="post-content" style="font-size: 1.125rem; line-height: 1.7;">
            <p>If you have ever stared at a slow query, ran <code>EXPLAIN</code>, and nodded pretending to understand why Postgres chose a Sequential Scan over your perfectly good Index, this article is for you.</p>
<p>Understanding the query optimizer is the single most important skill for high-performance database engineering. It is not magic; it is a cost-based algorithm that makes statistically driven decisions. When it fails, it usually isn't because the optimizer is "dumb", but because its cost model or statistics do not align with reality.</p>
<p>In this deep dive, we will walk through the internal machinery of the Postgres planner, dissect the cost model, and analyze real execution plans.</p>
<h2>The Life of a Query</h2>
<p>Before we get to planning, let's contextualize where it fits in the lifecycle of a query.</p>
<pre><code class="language-text">+----------------+      +----------------+      +----------------+
|  SQL Query     | ---&gt; |     Parser     | ---&gt; |   Parse Tree   |
+----------------+      +----------------+      +----------------+
                                                       |
                                                       v
+----------------+      +----------------+      +----------------+
|    Executor    | &lt;--- |    Planner     | &lt;--- |    Rewriter    |
+----------------+      +----------------+      +----------------+
        |
        v
    Results
</code></pre>
<ol>
<li><strong>Parser</strong>: Checks syntax and builds a parse tree.</li>
<li><strong>Rewriter</strong>: Applies rules (like Views) to modify the tree.</li>
<li><strong>Planner</strong>: The brain. It generates multiple valid execution paths (plans), estimates the cost of each, and picks the cheapest one.</li>
<li><strong>Executor</strong>: Runs the chosen plan.</li>
</ol>
<p>Our focus is step 3. The Planner is essentially solving a combinatorial optimization problem. For a simple <code>SELECT * FROM table</code>, there is effectively one path. But join 5 tables, add standard filters, and you suddenly have thousands of possible join orders and access methods.</p>
<h2>The Cost Model</h2>
<p>Postgres uses a <strong>Cost-Based Optimizer (CBO)</strong>. It doesn't pick the "fastest" plan; it picks the plan with the lowest arbitrary <em>cost units</em>.</p>
<p>These units are defined in <code>postgresql.conf</code>. The base unit is <code>seq_page_cost</code>, which is arbitrarily set to <strong>1.0</strong>. All other costs are relative to this.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Default</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>seq_page_cost</code></td>
<td style="text-align: left;">1.0</td>
<td style="text-align: left;">Cost to fetch a disk page sequentially.</td>
</tr>
<tr>
<td style="text-align: left;"><code>random_page_cost</code></td>
<td style="text-align: left;">4.0</td>
<td style="text-align: left;">Cost to fetch a disk page randomly.</td>
</tr>
<tr>
<td style="text-align: left;"><code>cpu_tuple_cost</code></td>
<td style="text-align: left;">0.01</td>
<td style="text-align: left;">Cost to process a single row (CPU).</td>
</tr>
<tr>
<td style="text-align: left;"><code>cpu_index_tuple_cost</code></td>
<td style="text-align: left;">0.005</td>
<td style="text-align: left;">Cost to process an index entry.</td>
</tr>
<tr>
<td style="text-align: left;"><code>cpu_operator_cost</code></td>
<td style="text-align: left;">0.0025</td>
<td style="text-align: left;">Cost to perform an operation (e.g., <code>+</code> or <code>=</code>).</td>
</tr>
</tbody>
</table>
<h3>The "SSD" Adjustment</h3>
<p>The default <code>random_page_cost</code> of 4.0 assumes mechanical spinning disks (HDD), where seeking is expensive. On modern cloud SSDs (gp3, io2), random seeks are almost as cheap as sequential ones.</p>
<p><strong>Pro Tip:</strong> If your indexes aren't being used, try lowering <code>random_page_cost</code> to <strong>1.1</strong> or <strong>1.2</strong>. This tells the planner that random seeks are cheap, making Index Scans more attractive.</p>
<pre><code class="language-sql">-- Check your current settings
SHOW random_page_cost;
SHOW seq_page_cost;
</code></pre>
<h2>Access Methods: Getting the Data</h2>
<p>The planner's first job is to figure out how to pull data from individual tables.</p>
<h3>1. Sequential Scan (<code>Seq Scan</code>)</h3>
<p>The brute force method. Read the table from beginning to end.<br />
*   <strong>When it's used:</strong> Small tables, or when fetching a large % of rows.<br />
*   <strong>Cost Formula:</strong> <code>(pages * seq_page_cost) + (rows * cpu_tuple_cost)</code></p>
<h3>2. Index Scan (<code>Index Scan</code>)</h3>
<p>Traverse the B-Tree to find Row IDs (CTIDs), then fetch the actual data pages.<br />
*   <strong>When it's used:</strong> High cardinality lookups (searching for a specific email or ID).<br />
*   <strong>The Catch:</strong> It involves random I/O. If you need to fetch 50% of the table, jumping around randomly is slower than just reading the whole file sequentially.</p>
<h3>3. Index Only Scan</h3>
<p>A special case where <em>all</em> requested columns are in the index itself. Postgres doesn't need to visit the main table (Heap) at all... <em>mostly</em>.<br />
*   <strong>The "Visibility Map" Caveat:</strong> Postgres uses MVCC. It must verify that the index entry is "visible" to your transaction. It checks the Visibility Map. If the page isn't marked "all visible", it <em>must</em> check the heap, degrading performance.</p>
<h3>4. Bitmap Heap Scan</h3>
<p>A hybrid approach.<br />
1.  <strong>Bitmap Index Scan:</strong> Scans the index and builds a bitmap of pages that need to be visited.<br />
2.  <strong>Bitmap Heap Scan:</strong> Reads those pages in sequential order.<br />
*   <strong>Benefit:</strong> Avoids random I/O thrashing while still using the index.</p>
<h2>Join Strategies: Putting It Together</h2>
<p>Once the planner knows how to get data, it must join it.</p>
<h3>Nested Loop Join</h3>
<p>The simple double for-loop.</p>
<pre><code class="language-python">for outer_row in outer_table:
    for inner_row in inner_table:
        if match(outer_row, inner_row):
            yield (outer_row, inner_row)
</code></pre>
<ul>
<li><strong>Best for:</strong> Small datasets or when the inner table is indexed on the join key.</li>
<li><strong>Complexity:</strong> O(N * M) (worst case), or O(N * log M) with an index.</li>
</ul>
<h3>Hash Join</h3>
<p>Builds a hash table in memory from the smaller table, then scans the larger table and probes the hash.<br />
*   <strong>Best for:</strong> Large, unsorted datasets. Equality joins only (<code>=</code>).<br />
*   <strong>Complexity:</strong> O(N + M).<br />
*   <strong>Memory Limit:</strong> Limited by <code>work_mem</code>. If the hash table doesn't fit in memory, it spills to disk, killing performance.</p>
<h3>Merge Join</h3>
<p>Sorts both tables on the join key, then zips them together.<br />
*   <strong>Best for:</strong> Very large tables that are already sorted (or cheap to sort).<br />
*   <strong>Complexity:</strong> O(N log N + M log M) (for sorting).</p>
<h2>Dissecting an EXPLAIN ANALYZE</h2>
<p>Let's look at a realistic scenario. We have a <code>orders</code> table (1M rows) and a <code>users</code> table (100k rows).</p>
<p>Query:</p>
<pre><code class="language-sql">EXPLAIN ANALYZE
SELECT u.email, o.total
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.created_at &gt; NOW() - INTERVAL '1 day';
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">Hash Join  (cost=2500.00..15000.00 rows=500 width=40) (actual time=15.000..45.000 rows=450 loops=1)
  Hash Cond: (o.user_id = u.id)
  -&gt;  Seq Scan on orders o  (cost=0.00..12000.00 rows=5000 width=12) (actual time=0.010..25.000 rows=5000 loops=1)
        Filter: (created_at &gt; (now() - '1 day'::interval))
        Rows Removed by Filter: 995000
  -&gt;  Hash  (cost=2000.00..2000.00 rows=100000 width=32) (actual time=10.000..10.000 rows=100000 loops=1)
        Buckets: 131072  Batches: 1  Memory Usage: 6000kB
        -&gt;  Seq Scan on users u  (cost=0.00..2000.00 rows=100000 width=32) (actual time=0.005..8.000 rows=100000 loops=1)
</code></pre>
<h3>Analysis</h3>
<ol>
<li><strong>Bottom Up:</strong> The plan starts at the leaves (Seq Scans).</li>
<li><strong><code>Seq Scan on users</code>:</strong> It read all 100k users. Cost was 2000.</li>
<li><strong><code>Hash</code>:</strong> It built a hash table of users. Memory Usage was 6MB. This fits comfortably in <code>work_mem</code> (default is 4MB, assume we bumped it).</li>
<li><strong><code>Seq Scan on orders</code>:</strong> It scanned the orders table. Notice <code>Rows Removed by Filter: 995000</code>. This is painful. We scanned 1M rows to find 5000 recent ones.<ul>
<li><strong>Optimization Opportunity:</strong> An index on <code>orders(created_at)</code> would turn this <code>Seq Scan</code> into an <code>Index Scan</code> or <code>Bitmap Heap Scan</code>.</li>
</ul>
</li>
<li><strong><code>Hash Join</code>:</strong> It probed the user hash table for each of the 5000 orders.</li>
</ol>
<h2>Statistics: The Planner's Map</h2>
<p>How did the planner guess <code>rows=5000</code> for the orders scan? Statistics.<br />
Postgres maintains a histogram and most common values (MCV) list for every column in <code>pg_statistic</code>.</p>
<p>The <strong>Auto-Vacuum</strong> daemon is responsible for updating these stats. If you disable autovacuum, statistics get stale, and the planner starts making terrible decisions (like Nested Looping two massive tables).</p>
<h2>Conclusion</h2>
<p>Query optimization is not about guessing. It's about:<br />
1.  <strong>Reading the Plan:</strong> Understand <code>EXPLAIN (ANALYZE, BUFFERS)</code>.<br />
2.  <strong>Understanding Costs:</strong> Know your <code>random_page_cost</code>.<br />
3.  <strong>Checking Stats:</strong> Ensure autovacuum is healthy.<br />
4.  <strong>Indexing Wisely:</strong> Indexes speed up reads but slow down writes.</p>
<p>Next time your query hangs, don't just add an index blindly. Ask the planner <em>why</em> it chose that path. The answer is usually in the costs.</p>
        </div>
    </article>

    </main>

    <footer class="site-footer container">
        <div class="social-links">
            <a href="https://github.com/dattskoushik" target="_blank">GitHub</a>
            <a href="https://linkedin.com/in/suchindrakoushik" target="_blank">LinkedIn</a>
            <a href="https://instagram.com/dattskoushik" target="_blank">Instagram</a>
            <a href="mailto:suchindra.formal@outlook.com">Email</a>
        </div>
        <p class="copyright">&copy; <script>document.write(new Date().getFullYear())</script> Suchindra Koushik. All rights reserved.</p>
    </footer>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>

</body>
</html>