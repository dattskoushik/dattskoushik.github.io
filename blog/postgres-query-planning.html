<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How PostgreSQL Query Planning Actually Works | Suchindra Koushik</title>
    <meta name="description" content="If you have ever stared at a slow query, ran `EXPLAIN`, and nodded pretending to understand why Postgres chose a Sequential Scan over your perfectly good Ind...">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/main.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="../assets/js/theme.js"></script>
</head>
<body>

    <header class="site-header">
        <div class="container">
            <a href="../" class="logo">Suchindra Koushik</a>
            <button class="mobile-menu-btn" aria-label="Menu" aria-expanded="false">☰</button>
            <nav class="nav-links">
                <a href="../">Home</a>
                <a href="index.html" class="active">Writing</a>
                <a href="../projects.html">Projects</a>
                <a href="../about.html">About</a>
                <a href="../resume.html">Resume</a>
                <button id="theme-toggle" aria-label="Toggle theme">☀️</button>
            </nav>
        </div>
    </header>

    <main class="container">
        <article class="hero" style="padding-bottom: var(--space-md); max-width: 800px; margin: 0 auto;">
            <a href="index.html" style="font-size: 0.875rem; color: var(--text-muted); text-decoration: none; display: inline-block; margin-bottom: var(--space-sm);">&larr; Back to Writing</a>
            <div class="hero-meta" style="margin-top: 0; margin-bottom: var(--space-sm);">
                Data Engineering • October 2023
            </div>
            <h1 style="margin-bottom: var(--space-md);">How PostgreSQL Query Planning Actually Works</h1>
        </article>

        <div class="post-content">
            <p>If you have ever stared at a slow query, ran <code>EXPLAIN</code>, and nodded pretending to understand why Postgres chose a Sequential Scan over your perfectly good Index, this article is for you.</p>
<p>Understanding the query optimizer is the single most important skill for high-performance database engineering. It is not magic; it is a cost-based algorithm that makes statistically driven decisions. When it fails, it usually isn't because the optimizer is "dumb", but because its cost model or statistics do not align with reality.</p>
<p>In this deep dive, we will walk through the internal machinery of the Postgres planner, dissect the cost model, and analyze real execution plans.</p>
<h2>The Life of a Query</h2>
<p>Before we get to planning, let's contextualize where it fits in the lifecycle of a query.</p>
<pre><code class="language-text">+----------------+      +----------------+      +----------------+
|  SQL Query     | ---&gt; |     Parser     | ---&gt; |   Parse Tree   |
+----------------+      +----------------+      +----------------+
                                                       |
                                                       v
+----------------+      +----------------+      +----------------+
|    Executor    | &lt;--- |    Planner     | &lt;--- |    Rewriter    |
+----------------+      +----------------+      +----------------+
        |
        v
    Results
</code></pre>
<ol>
<li><strong>Parser</strong>: Checks syntax and builds a parse tree.</li>
<li><strong>Rewriter</strong>: Applies rules (like Views) to modify the tree.</li>
<li><strong>Planner</strong>: The brain. It generates multiple valid execution paths (plans), estimates the cost of each, and picks the cheapest one.</li>
<li><strong>Executor</strong>: Runs the chosen plan.</li>
</ol>
<p>Our focus is step 3. The Planner is essentially solving a combinatorial optimization problem. For a simple <code>SELECT * FROM table</code>, there is effectively one path. But join 5 tables, add standard filters, and you suddenly have thousands of possible join orders and access methods.</p>
<h2>The Cost Model</h2>
<p>Postgres uses a <strong>Cost-Based Optimizer (CBO)</strong>. It doesn't pick the "fastest" plan; it picks the plan with the lowest arbitrary <em>cost units</em>.</p>
<p>These units are defined in <code>postgresql.conf</code>. The base unit is <code>seq_page_cost</code>, which is arbitrarily set to <strong>1.0</strong>. All other costs are relative to this.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Default</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>seq_page_cost</code></td>
<td style="text-align: left;">1.0</td>
<td style="text-align: left;">Cost to fetch a disk page sequentially.</td>
</tr>
<tr>
<td style="text-align: left;"><code>random_page_cost</code></td>
<td style="text-align: left;">4.0</td>
<td style="text-align: left;">Cost to fetch a disk page randomly.</td>
</tr>
<tr>
<td style="text-align: left;"><code>cpu_tuple_cost</code></td>
<td style="text-align: left;">0.01</td>
<td style="text-align: left;">Cost to process a single row (CPU).</td>
</tr>
<tr>
<td style="text-align: left;"><code>cpu_index_tuple_cost</code></td>
<td style="text-align: left;">0.005</td>
<td style="text-align: left;">Cost to process an index entry.</td>
</tr>
<tr>
<td style="text-align: left;"><code>cpu_operator_cost</code></td>
<td style="text-align: left;">0.0025</td>
<td style="text-align: left;">Cost to perform an operation (e.g., <code>+</code> or <code>=</code>).</td>
</tr>
</tbody>
</table>
<h3>The "SSD" Adjustment</h3>
<p>The default <code>random_page_cost</code> of 4.0 assumes mechanical spinning disks (HDD), where seeking is expensive. On modern cloud SSDs (gp3, io2), random seeks are almost as cheap as sequential ones.</p>
<p><strong>Pro Tip:</strong> If your indexes aren't being used, try lowering <code>random_page_cost</code> to <strong>1.1</strong> or <strong>1.2</strong>. This tells the planner that random seeks are cheap, making Index Scans more attractive.</p>
<pre><code class="language-sql">-- Check your current settings
SHOW random_page_cost;
SHOW seq_page_cost;
</code></pre>
<h2>Access Methods: Getting the Data</h2>
<p>The planner's first job is to figure out how to pull data from individual tables.</p>
<h3>1. Sequential Scan (<code>Seq Scan</code>)</h3>
<p>The brute force method. Read the table from beginning to end.
*   <strong>When it's used:</strong> Small tables, or when fetching a large % of rows.
*   <strong>Cost Formula:</strong> <code>(pages * seq_page_cost) + (rows * cpu_tuple_cost)</code></p>
<h3>2. Index Scan (<code>Index Scan</code>)</h3>
<p>Traverse the B-Tree to find Row IDs (CTIDs), then fetch the actual data pages.
*   <strong>When it's used:</strong> High cardinality lookups (searching for a specific email or ID).
*   <strong>The Catch:</strong> It involves random I/O. If you need to fetch 50% of the table, jumping around randomly is slower than just reading the whole file sequentially.</p>
<h3>3. Index Only Scan</h3>
<p>A special case where <em>all</em> requested columns are in the index itself. Postgres doesn't need to visit the main table (Heap) at all... <em>mostly</em>.
*   <strong>The "Visibility Map" Caveat:</strong> Postgres uses MVCC. It must verify that the index entry is "visible" to your transaction. It checks the Visibility Map. If the page isn't marked "all visible", it <em>must</em> check the heap, degrading performance.</p>
<h3>4. Bitmap Heap Scan</h3>
<p>A hybrid approach.
1.  <strong>Bitmap Index Scan:</strong> Scans the index and builds a bitmap of pages that need to be visited.
2.  <strong>Bitmap Heap Scan:</strong> Reads those pages in sequential order.
*   <strong>Benefit:</strong> Avoids random I/O thrashing while still using the index.</p>
<h2>Join Strategies: Putting It Together</h2>
<p>Once the planner knows how to get data, it must join it.</p>
<h3>Nested Loop Join</h3>
<p>The simple double for-loop.</p>
<pre><code class="language-python">for outer_row in outer_table:
    for inner_row in inner_table:
        if match(outer_row, inner_row):
            yield (outer_row, inner_row)
</code></pre>
<ul>
<li><strong>Best for:</strong> Small datasets or when the inner table is indexed on the join key.</li>
<li><strong>Complexity:</strong> O(N * M) (worst case), or O(N * log M) with an index.</li>
</ul>
<h3>Hash Join</h3>
<p>Builds a hash table in memory from the smaller table, then scans the larger table and probes the hash.
*   <strong>Best for:</strong> Large, unsorted datasets. Equality joins only (<code>=</code>).
*   <strong>Complexity:</strong> O(N + M).
*   <strong>Memory Limit:</strong> Limited by <code>work_mem</code>. If the hash table doesn't fit in memory, it spills to disk, killing performance.</p>
<h3>Merge Join</h3>
<p>Sorts both tables on the join key, then zips them together.
*   <strong>Best for:</strong> Very large tables that are already sorted (or cheap to sort).
*   <strong>Complexity:</strong> O(N log N + M log M) (for sorting).</p>
<h2>Dissecting an EXPLAIN ANALYZE</h2>
<p>Let's look at a realistic scenario. We have a <code>orders</code> table (1M rows) and a <code>users</code> table (100k rows).</p>
<p>Query:</p>
<pre><code class="language-sql">EXPLAIN ANALYZE
SELECT u.email, o.total
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.created_at &gt; NOW() - INTERVAL '1 day';
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">Hash Join  (cost=2500.00..15000.00 rows=500 width=40) (actual time=15.000..45.000 rows=450 loops=1)
  Hash Cond: (o.user_id = u.id)
  -&gt;  Seq Scan on orders o  (cost=0.00..12000.00 rows=5000 width=12) (actual time=0.010..25.000 rows=5000 loops=1)
        Filter: (created_at &gt; (now() - '1 day'::interval))
        Rows Removed by Filter: 995000
  -&gt;  Hash  (cost=2000.00..2000.00 rows=100000 width=32) (actual time=10.000..10.000 rows=100000 loops=1)
        Buckets: 131072  Batches: 1  Memory Usage: 6000kB
        -&gt;  Seq Scan on users u  (cost=0.00..2000.00 rows=100000 width=32) (actual time=0.005..8.000 rows=100000 loops=1)
</code></pre>
<h3>Analysis</h3>
<ol>
<li><strong>Bottom Up:</strong> The plan starts at the leaves (Seq Scans).</li>
<li><strong><code>Seq Scan on users</code>:</strong> It read all 100k users. Cost was 2000.</li>
<li><strong><code>Hash</code>:</strong> It built a hash table of users. Memory Usage was 6MB. This fits comfortably in <code>work_mem</code> (default is 4MB, assume we bumped it).</li>
<li><strong><code>Seq Scan on orders</code>:</strong> It scanned the orders table. Notice <code>Rows Removed by Filter: 995000</code>. This is painful. We scanned 1M rows to find 5000 recent ones.<ul>
<li><strong>Optimization Opportunity:</strong> An index on <code>orders(created_at)</code> would turn this <code>Seq Scan</code> into an <code>Index Scan</code> or <code>Bitmap Heap Scan</code>.</li>
</ul>
</li>
<li><strong><code>Hash Join</code>:</strong> It probed the user hash table for each of the 5000 orders.</li>
</ol>
<h2>Statistics: The Planner's Map</h2>
<p>How did the planner guess <code>rows=5000</code> for the orders scan? Statistics.
Postgres maintains a histogram and most common values (MCV) list for every column in <code>pg_statistic</code>.</p>
<p>The <strong>Auto-Vacuum</strong> daemon is responsible for updating these stats. If you disable autovacuum, statistics get stale, and the planner starts making terrible decisions (like Nested Looping two massive tables).</p>
<h2>Conclusion</h2>
<p>Query optimization is not about guessing. It's about:
1.  <strong>Reading the Plan:</strong> Understand <code>EXPLAIN (ANALYZE, BUFFERS)</code>.
2.  <strong>Understanding Costs:</strong> Know your <code>random_page_cost</code>.
3.  <strong>Checking Stats:</strong> Ensure autovacuum is healthy.
4.  <strong>Indexing Wisely:</strong> Indexes speed up reads but slow down writes.</p>
<p>Next time your query hangs, don't just add an index blindly. Ask the planner <em>why</em> it chose that path. The answer is usually in the costs.</p>
        </div>
    </main>

    <footer class="site-footer container">
        <p class="copyright">&copy; <script>document.write(new Date().getFullYear())</script> Suchindra Koushik. All rights reserved.</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
</body>
</html>
